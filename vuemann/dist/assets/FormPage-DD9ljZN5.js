import{_ as n,c as i,a as r,l as a,d as s,b as l,w as o,F as d,r as u,o as c}from"./index-CFtw_ocM.js";const p={};function m(b,e){const t=u("router-link");return c(),i(d,null,[e[5]||(e[5]=r("h1",{class:"h1"}," Service Form ",-1)),r("p",null,[e[1]||(e[1]=s(" Ce service regroupe toutes la partie liée au formulaire. Que se soit des components ou un système de validation. Vous pouvez consulter la ",-1)),l(t,{to:{name:"services.form.inputs"},class:"link-underline underline"},{default:o(()=>[...e[0]||(e[0]=[s("liste des inputs disponible",-1)])]),_:1}),e[2]||(e[2]=s(". ",-1))]),e[6]||(e[6]=a('<h2 class="h2">Installation</h2><ul class="list ml-25"><li>Importer formService dans l&#39;objet services situé dans le fichier main.js.</li></ul><h3 class="h3">Dépendances</h3><p>Ce service est dépedants des services :</p><ul class="list ml-25"><li>flash - methode error</li><li>locale - methode t</li></ul><h2 class="h2">Fonctionnement</h2><p> La logique de la validation d&#39;un formulaire est contenue dans un fichier de type <span class="badge-code">FormRequest</span>. Ce fichier doit contenir une fonction prenant en paramètre un objet des données à valider. Dans cette fonction est défini l&#39;ensemble des règles que doivent respecter les datas. Les datas et les régles sont passées à la fonction validateForm dont le résultat est retourné. </p><h3 class="h3">Object rules</h3><p> Cet objet dois être instancié dans la fonction de validation et transmis à la fonction validateForm. Il contient l&#39;ensemble des règles de validation de votre formulaire. Il contient une clé par nom d&#39;input qui représente l&#39;ensemble des règles pour cet input. L&#39;objet des règles d&#39;input est composé de trois propriétés: </p><ul class="list ml-25"><li>rules (obligatoire) - array / string : contient l&#39;ensemble des règles appliquées à cet input.</li><li>tests - objet : permet de définir des tests personnalisés pour cet input.</li><li>errors - objet : permet de personnaliser les clés de traduction des erreurs pour tous les tests (prédéfinis et personnalisés).</li></ul><p><i class="fa-solid fa-triangle-exclamation color-danger mr-5"></i> le nom d&#39;input global_tests est réservé <i class="fa-solid fa-triangle-exclamation color-danger ml-5"></i></p><h3 class="h3">Exemple de fichier de type FormRequest</h3><div class="div-code"> export const validateSearchPatientForm = datas =&gt; {<br>  const rules = {<br>   lastname : {<br>    rules : &#39;required|length_check&#39;,<br>    tests : {<br>     length_check: value =&gt; value.length &lt; 3 ? &#39;length_check&#39; : &#39;&#39;<br>    }<br>    errors : {<br>     length_check: &#39;field_lastname_short&#39;<br>    }<br>   },<br>   birthdate : {<br>    rules : &#39;required|datePast:yyyy-mm-dd&#39;,<br>    errors : {<br>     required : &#39;field_birthdate_required&#39;<br>    }<br>   },<br>  }<br>  <br>  return validateForm(rules, datas)<br> }<br></div><p> Il y a possibilité de faire du formatage de datas avant de les transmettre à la fonction validateForm. </p><div class="div-code"> datas.lastname = datas.lastname.toUpperCase()<br> <br> return validateForm(rules, datas) </div><h2 class="h2">Fonctionnement des tests</h2><p> Les tests peuvent être définis de deux manières différentes : </p><ul class="list ml-25"><li><strong>Tests prédéfinis</strong> : définis dans la propriété <span class="badge-code">rules</span> avec des chaînes de caractères.</li><li><strong>Tests personnalisés</strong> : définis dans la propriété <span class="badge-code">tests</span> avec des fonctions.</li></ul><div class="div-code"> lastname : {<br>  rules : &#39;required|length_check&#39;,<br>  tests : {<br>   length_check: value =&gt; value.length &lt; 3 ? &#39;lastname_short&#39; : &#39;&#39;<br>  }<br> }, </div><p> Il est possible de chainer les tests prédéfinis en les séparants par des <span class="badge-code">|</span></p><div class="div-code"><span class="color-neutral-500">//exemple</span><br> lastname : {<br>  rules : [<br>  &#39;required&#39;,<br>  &#39;date:yyyy-mm-dd&#39;<br>  ]<br> },<br> <br> <span class="color-neutral-500">//peut être écrit</span><br> lastname : {<br>  rules : &#39;required|date:yyyy-mm-dd&#39;<br> }, </div><p> Les tests prédéfinis peuvent avoir des paramètres. Dans l&#39;exemple ci-dessous, le test prédéfini date à pour argument le format de la date souhaité. </p><div class="div-code"> lastname : {<br>  rules : &#39;date:yyyy-mm-dd&#39;<br> }, </div>',23)),r("p",null,[e[4]||(e[4]=s(" Une liste des tests reprenant leur fonctionnement et les arguments requis est disponible : ",-1)),l(t,{to:{name:"services.form.defaultTests"},class:"link-underline underline"},{default:o(()=>[...e[3]||(e[3]=[s("liste des tests",-1)])]),_:1})]),e[7]||(e[7]=a('<h3 class="h3">Tests personnalisés</h3><p> Les tests personnalisés sont définis dans la propriété <span class="badge-code">tests</span> sous forme d&#39;objet avec des fonctions. Chaque fonction prend deux paramètres: </p><ul class="list ml-25"><li><strong>value</strong> : la data à tester</li><li><strong>datas</strong> : l&#39;ensemble des données soumis à la validation</li></ul><h4 class="h4">Retour</h4><p> Si la validation échoue, il faut retourner le <strong>nom du test</strong> pour récupérer la clé de traduction correspondante dans la propriété <span class="badge-code">errors</span>, sinon une string vide. </p><div class="div-code"><span class="color-neutral-500">//exemple avec tests personnalisés uniquement</span> <br> lastname : {<br>  rules : &#39;&#39;,<br>  tests : {<br>   length_check: value =&gt; value.length &lt; 3 ? &#39;length_check&#39; : &#39;&#39;<br>  }<br>  errors : {<br>   length_check: &#39;field_lastname_short&#39;<br>  }<br> },<br> <br> <span class="color-neutral-500">//exemple avec le paramètre datas</span><br> firstname : {<br>  rules : &#39;&#39;,<br>  tests : {<br>   conditional_required: (value, datas) =&gt; datas.lastname &amp;&amp; !value ? &#39;conditional_required&#39; : &#39;&#39;<br>  }<br>  errors : {<br>   conditional_required: &#39;field_firstname_required_if_lastname&#39;<br>  }<br> },<br> <br> <span class="color-neutral-500">//exemple avec tests prédéfinis ET personnalisés</span><br> email : {<br>  rules : &#39;required|email&#39;,<br>  tests : {<br>   domain_check: value =&gt; value.includes(&#39;@company.com&#39;) ? &#39;&#39; : &#39;domain_check&#39;<br>  }<br>  errors : {<br>   domain_check: &#39;field_email_domain_invalid&#39;<br>  }<br> }<br></div><h3 class="h3">Tests globaux</h3><p> Il est possible de tester les interactions entre les inputs grace aux tests globaux. Pour cela, la clé dans l&#39;objet rules doit être <span class="badge-code">global_tests</span>. </p><p> Les tests globaux sont exécutés après tous les tests individuels des inputs. Ils reçoivent l&#39;ensemble des données du formulaire et permettent de valider des règles métier complexes qui impliquent plusieurs champs. </p><h4 class="h4">Structure des tests globaux</h4><p> Les tests globaux suivent la même structure que les tests d&#39;input individuels : </p><ul class="list ml-25"><li>Ils peuvent être des chaînes de caractères (tests prédéfinis) ou des fonctions personnalisées</li><li>Ils reçoivent l&#39;ensemble des données du formulaire en paramètre</li><li>Ils doivent retourner une chaîne vide si la validation réussit, ou un message d&#39;erreur si elle échoue</li></ul><h4 class="h4">Exemple de tests globaux</h4><div class="div-code"> const rules = {<br>  global_tests: [<br>   // Test personnalisé pour vérifier qu&#39;un utilisateur admin ne peut pas être créé<br>   datas =&gt; (datas.username === &#39;admin&#39; ? &#39;Admin is not allowed&#39; : &#39;&#39;),<br>   // Test pour vérifier que si le nom de famille est présent, le prénom est requis<br>   datas =&gt; (datas.lastname &amp;&amp; !datas.firstname ? &#39;Le prénom est requis si le nom de famille est présent&#39; : &#39;&#39;),<br>   // Test pour vérifier que la date de fin est postérieure à la date de début<br>   datas =&gt; {<br>    if (datas.start_date &amp;&amp; datas.end_date) {<br>     return new Date(datas.end_date) &gt; new Date(datas.start_date) ? &#39;&#39; : &#39;La date de fin doit être postérieure à la date de début&#39;;<br>    }<br>    return &#39;&#39;;<br>   }<br>  ],<br>  username: { rules: &#39;required&#39; },<br>  lastname: { rules: &#39;required&#39; },<br>  firstname: { rules: &#39;&#39; },<br>  start_date: { rules: &#39;date:yyyy-mm-dd&#39; },<br>  end_date: { rules: &#39;date:yyyy-mm-dd&#39; }<br> }; </div><h4 class="h4">Affichage des erreurs globales</h4><p> Les erreurs des tests globaux sont stockées avec la clé <span class="badge-code">global_tests</span> dans l&#39;objet d&#39;erreurs. Vous pouvez utiliser le composant <span class="badge-code">ErrorFormComponent</span> pour les afficher : </p><div class="div-code"><span class="color-neutral-500">// Dans votre composant Vue</span><br> import ErrorFormComponent from &quot;@brugmann/vuemann/src/services/form/views/ErrorFormComponent.vue&quot;<br><br><span class="color-neutral-500">// Dans le template</span><br> &lt;ErrorFormComponent name=&quot;global_tests&quot; /&gt; </div><h4 class="h4">Utilisation avec getError et hasError</h4><p> Vous pouvez également vérifier et récupérer les erreurs globales avec les fonctions du service : </p><div class="div-code"><span class="color-neutral-500">// Vérifier s&#39;il y a des erreurs globales</span><br> if (form.hasError(&#39;global_tests&#39;)) {<br>  const globalError = form.getError(&#39;global_tests&#39;);<br>  console.log(&#39;Erreur globale:&#39;, globalError);<br> }<br><br><span class="color-neutral-500">// Effacer les erreurs globales</span><br> form.clearError(&#39;global_tests&#39;); </div><h2 class="h2">Fonctions accessibles depuis le gestionnaire de service</h2><h3 class="h3"><i class="fa-solid fa-diamond mr-5"></i>validateForm</h3><p> Permet de vérifier un formulaire en fonction d&#39;un objet contenant les règles attendus. </p><h4 class="h4">Paramètres</h4><table class="t-default"><thead><tr><th>Nom</th><th>Type</th><th>Required</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>current_rules</td><td>String</td><td>oui</td><td> Objet reprenant l&#39;ensemble des règles de validation du formulaire. </td></tr><tr><td>current_datas</td><td>Object</td><td>oui</td><td> Objet reprenant l&#39;ensemble des données du formulaire. </td></tr><tr><td>options</td><td>Object</td><td>non</td><td> Options de validation. </td></tr></tbody></table><h4 class="h4">Options</h4><table class="t-default"><thead><tr><th>Nom</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>form</td><td>string</td><td> undefined </td><td> Permet de spécifier le nom du formulaire et de modifier le nom des inputs et des erreurs. </td></tr></tbody></table><h4 class="h4">Retour</h4><div class="div-code"> {<br>  valide : bool,<br>  datas : object,<br>  errors : object (default {})<br> } </div><h4 class="h4">Utilisation</h4><div class="div-code"><span class="color-neutral-500">//appel clasique</span><br> import { servicesM } from &quot;@brugmann/vuemann/src/services/services-manager.js&quot;<br> <br> servicesM.service(&#39;form:validateForm&#39;, [current_rules, current_datas])<br><br><span class="color-neutral-500">//appel avec le raccourci </span><br> import { validateForm } from &quot;@brugmann/vuemann/src/services/services-helper.js&quot;<br> validateForm(current_rules, current_datas)<br></div><h3 class="h3"><i class="fa-solid fa-diamond mr-5"></i>getErrors</h3><p> Retourne l&#39;ensemble des erreurs du formulaire. </p><h4 class="h4">Utilisation</h4><div class="div-code"><span class="color-neutral-500">//appel clasique</span><br> import { servicesM } from &quot;@brugmann/vuemann/src/services/services-manager.js&quot;<br> servicesM.service(&#39;form:getErrors&#39;)<br> <br><span class="color-neutral-500">//appel avec le raccourci </span><br> import { form } from &quot;@brugmann/vuemann/src/services/services-helper.js&quot;<br> form.getErrors()<br></div><h3 class="h3"><i class="fa-solid fa-diamond mr-5"></i>getError</h3><p> Retourne l&#39;erreur d&#39;un input. </p><h4 class="h4">Paramètres</h4><table class="t-default"><thead><tr><th>Nom</th><th>Type</th><th>Required</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>input_name</td><td>String</td><td>oui</td><td> Nom de l&#39;input. </td></tr></tbody></table><h4 class="h4">Utilisation</h4><div class="div-code"><span class="color-neutral-500">//appel clasique</span><br> import { servicesM } from &quot;@brugmann/vuemann/src/services/services-manager.js&quot;<br> servicesM.service(&#39;form:getError&#39;, [input_name])<br> <br><span class="color-neutral-500">//appel avec le raccourci </span><br> import { form } from &quot;@brugmann/vuemann/src/services/services-helper.js&quot;<br> form.getError(input_name)<br></div><h3 class="h3"><i class="fa-solid fa-diamond mr-5"></i>hasError</h3><p> Retourne true si l&#39;input a une erreur. </p><h4 class="h4">Paramètres</h4><table class="t-default"><thead><tr><th>Nom</th><th>Type</th><th>Required</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>input_name</td><td>String</td><td>oui</td><td> Nom de l&#39;input. </td></tr></tbody></table><h4 class="h4">Utilisation</h4><div class="div-code"><span class="color-neutral-500">//appel clasique</span><br> import { servicesM } from &quot;@brugmann/vuemann/src/services/services-manager.js&quot;<br> servicesM.service(&#39;form:hasError&#39;, [input_name])<br> <br><span class="color-neutral-500">//appel avec le raccourci </span><br> import { form } from &quot;@brugmann/vuemann/src/services/services-helper.js&quot;<br> form.hasError(input_name)<br></div><h3 class="h3"><i class="fa-solid fa-diamond mr-5"></i>clearError</h3><p> Supprime l&#39;erreur d&#39;un input. </p><h4 class="h4">Paramètres</h4><table class="t-default"><thead><tr><th>Nom</th><th>Type</th><th>Required</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>input_name</td><td>String</td><td>oui</td><td> Nom de l&#39;input. </td></tr></tbody></table><h4 class="h4">Utilisation</h4><div class="div-code"><span class="color-neutral-500">//appel clasique</span><br> import { servicesM } from &quot;@brugmann/vuemann/src/services/services-manager.js&quot;<br> servicesM.service(&#39;form:clearError&#39;, [input_name])<br> <br><span class="color-neutral-500">//appel avec le raccourci </span><br> import { form } from &quot;@brugmann/vuemann/src/services/services-helper.js&quot;<br> form.clearError(input_name)<br></div><h3 class="h3"><i class="fa-solid fa-diamond mr-5"></i>clearErrors</h3><p> Supprime toutes les erreurs du formulaire. </p><h4 class="h4">Utilisation</h4><div class="div-code"><span class="color-neutral-500">//appel clasique</span><br> import { servicesM } from &quot;@brugmann/vuemann/src/services/services-manager.js&quot;<br> servicesM.service(&#39;form:clearErrors&#39;)<br> <br><span class="color-neutral-500">//appel avec le raccourci </span><br> import { form } from &quot;@brugmann/vuemann/src/services/services-helper.js&quot;<br> form.clearErrors()<br></div><h2 class="h2">Affichage des erreurs</h2><p> Le service form fournit un composant <span class="badge-code">ErrorFormComponent</span> pour afficher tous types d&#39;erreurs de formulaire. </p><h3 class="h3">Installation du composant</h3><div class="div-code"><span class="color-neutral-500">// Dans votre composant Vue</span><br> import ErrorFormComponent from &quot;@brugmann/vuemann/src/services/form/views/ErrorFormComponent.vue&quot; </div><h3 class="h3">Utilisation du composant</h3><p><span class="badge-code">ErrorFormComponent</span> peut être utilisé pour afficher différents types d&#39;erreurs : </p><h4 class="h4">Erreurs d&#39;input individuels</h4><div class="div-code"><span class="color-neutral-500">// Dans le template</span><br> &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;<br> &lt;ErrorFormComponent name=&quot;username&quot; /&gt; </div><h4 class="h4">Erreurs globales</h4><div class="div-code"><span class="color-neutral-500">// Dans le template</span><br> &lt;ErrorFormComponent name=&quot;global_tests&quot; /&gt; </div><h4 class="h4">Erreurs personnalisées</h4><div class="div-code"><span class="color-neutral-500">// Dans le template</span><br> &lt;ErrorFormComponent name=&quot;custom_error&quot; /&gt; </div><h3 class="h3">Inclusion automatique dans les composants</h3><p> Le composant <span class="badge-code">ErrorFormComponent</span> est automatiquement inclus dans tous les composants d&#39;input du service form. </p><p> Cela signifie que vous n&#39;avez pas besoin d&#39;ajouter manuellement <span class="badge-code">ErrorFormComponent</span> lorsque vous utilisez les composants du service form. Les erreurs s&#39;afficheront automatiquement en dessous du champ correspondant. </p><h4 class="h4">Exemple avec composants du service form</h4><div class="div-code"><span class="color-neutral-500">// Les erreurs s&#39;affichent automatiquement</span><br> &lt;Input name=&quot;username&quot; /&gt;<br> &lt;Select name=&quot;country&quot; :options=&quot;countries&quot; /&gt;<br> &lt;InputSearch name=&quot;search&quot; /&gt;<br> &lt;InputDate name=&quot;birthdate&quot; /&gt;<br> &lt;Textarea name=&quot;description&quot; /&gt;<br> &lt;Switch name=&quot;active&quot; /&gt;<br><br><span class="color-neutral-500">// Pas besoin d&#39;ajouter ErrorFormComponent manuellement</span><br><span class="color-neutral-500">// Les erreurs s&#39;affichent automatiquement sous chaque champ</span></div><h4 class="h4">Utilisation manuelle d&#39;ErrorFormComponent</h4><p> Vous devez utiliser <span class="badge-code">ErrorFormComponent</span> manuellement uniquement pour : </p><ul class="list ml-25"><li>Les erreurs globales (<span class="badge-code">name=&quot;global_tests&quot;</span>)</li><li>Les erreurs personnalisées non liées à un champ spécifique</li><li>Les champs HTML natifs (input, select, etc.) non encapsulés dans les composants du service</li></ul>',77))],64)}const v=n(p,[["render",m]]);export{v as default};
