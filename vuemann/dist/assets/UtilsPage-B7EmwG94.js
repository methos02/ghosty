import{_ as r,c as n,l as s,a as o,d as t,b as i,w as l,F as c,r as d,o as u}from"./index-CFtw_ocM.js";const p={};function h(b,e){const a=d("router-link");return u(),n(c,null,[e[3]||(e[3]=s('<h1 class="h1">Service Utils</h1><p> Ce service regroupe l&#39;ensemble des fonctionnalités génériques d&#39;une application. </p><h2 class="h2">Installation</h2><ul class="list ml-25"><li>Importer utilsService dans l&#39;objet services situé dans le fichier main.js.</li><li>Importer utilsPlugin dans l&#39;array plugins_synchrone dans le fichier main.js.</li></ul><h3 class="h3">Dépendances</h3><p>Ce service est dépedants des services :</p><ul class="list ml-25"><li>ajax - methode req</li><li>router - methode hasRoute (pour DebugBar)</li></ul><h2 class="h2">Fonctions accessibles depuis le gestionnaire de service</h2><h3 class="h3"><i class="fa-solid fa-diamond mr-5"></i>apiStatus</h3><p> Permet de récupérer le status des apis utilisées par l&#39;application. </p><h4 class="h4">configuration</h4>',11)),o("p",null,[e[1]||(e[1]=t(" Le service utils va automatiquement récupérer les apis renseignées dans le fichier de config ",-1)),i(a,{to:{name:"config.app"},class:"link-underline underline"},{default:l(()=>[...e[0]||(e[0]=[t("appConfig",-1)])]),_:1}),e[2]||(e[2]=t(". ",-1))]),e[4]||(e[4]=s('<p> Vous pouvez desactiver la vérification du status d&#39;une api en ajouter à sa clé dans le fichier appConfig l&#39;option <span class="badge-code">status:false</span></p><h4 class="h4">utilisation</h4><div class="div-code"> import { servicesM } from &quot;@brugmann/vuemann/src/services/services-manager.js&quot;<br> <br> servicesM.service(&#39;utilis:apiStatus&#39;)<br></div><h2 class="h2">Composants inclus</h2><h3 class="h3"><i class="fa-solid fa-bug mr-5"></i>DebugBar</h3><p> La barre de debug s&#39;affiche automatiquement en bas à gauche de l&#39;écran et fournit des informations utiles pour le développement : </p><ul class="list ml-25 f-column g-5"><li><strong>Version de l&#39;application</strong> : Affiche la version actuelle de l&#39;application</li><li><strong>Mode de développement</strong> : Indique si l&#39;application est en mode test ou production</li><li><strong>Mise à jour disponible</strong> : Alerte si une nouvelle version est disponible</li><li><strong>Lien changelog</strong> : Affiche un lien &quot;Liste des modifications&quot; vers la page changelog si la route existe</li></ul><h4 class="h4">Lien changelog conditionnel</h4><p> Le lien vers la liste des modifications n&#39;apparaît que si une route nommée <span class="badge-code">changelog</span> est définie dans votre configuration de routes. Cette vérification utilise la méthode <span class="badge-code">router.hasRoute(&#39;changelog&#39;)</span> du service router. </p><h3 class="h3"><i class="fa-solid fa-app-store mr-5"></i>AppComponent</h3><p> Composant racine chargé d&#39;orchestrer l&#39;état global de l&#39;application (<span class="badge-code">INIT</span>, <span class="badge-code">LOADING</span>, <span class="badge-code">LOADED</span>, <span class="badge-code">ERROR</span>) via le <span class="badge-code">utilsStore</span>. Il affiche: </p><ul class="list ml-25 f-column g-5"><li><strong>Router</strong> quand l&#39;application est <span class="badge-code">LOADED</span></li><li><strong>Un loader</strong> quand l&#39;application est <span class="badge-code">INIT</span> ou <span class="badge-code">LOADING</span></li><li><strong>Une vue d&#39;erreur</strong> quand l&#39;application est en <span class="badge-code">ERROR</span> avec un bouton &quot;Réessayer&quot;</li></ul><h4 class="h4">Propriétés</h4><table class="t-default mb-15 w-100"><thead><tr><th>Nom</th><th>Type</th><th>Required</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>cb</td><td>Function</td><td>-</td><td>undefined</td><td>Callback asynchrone exécuté au montage. Si retourne false, l&#39;app passe en état ERROR.</td></tr></tbody></table><h4 class="h4">Exemple</h4><div class="div-code"><span class="color-neutral-700">// App.vue</span><br> &lt;script setup&gt;<br>   import AppComponent from &#39;@brugmann/vuemann/src/services/utils/views/AppComponent.vue&#39;<br>   import { utilsService } from &#39;@brugmann/vuemann/src/services/utils/utils-service.js&#39;<br>   import { utilsStore } from &#39;@brugmann/vuemann/src/services/utils/utils-store.js&#39;<br>   import { APP_STATUS } from &#39;@brugmann/vuemann/src/services/utils/utils-constants.js&#39;<br>   utilsStore.setAppStatus(APP_STATUS.INIT)<br>   const initApp = async () =&gt; {<br>     return await utilsService.apiStatus()<br>   }<br> &lt;/script&gt;<br> &lt;template&gt;<br>   &lt;AppComponent :cb=&quot;initApp&quot; /&gt;<br> &lt;/template&gt; </div><h4 class="h4">Gestion des erreurs d&#39;authentification</h4><p> Le composant AppComponent gère intelligemment les erreurs d&#39;authentification (401 Unauthorized, 403 Forbidden) : </p><ul class="list ml-25 f-column g-5"><li><strong>Pages publiques</strong> : Les pages <span class="badge-code">login</span> et <span class="badge-code">changelog</span> restent accessibles même en cas d&#39;erreur d&#39;authentification</li><li><strong>Pas de message d&#39;erreur</strong> : Les erreurs 401/403 n&#39;affichent pas de message d&#39;erreur à l&#39;utilisateur car il sera automatiquement redirigé vers la page de login</li><li><strong>Réexécution automatique</strong> : Après une connexion réussie, le callback se réexécute automatiquement pour recharger l&#39;application</li></ul><h4 class="h4">Format de retour attendu</h4><p> Le callback doit retourner un objet avec les propriétés suivantes : </p><table class="t-default mb-15 w-100"><thead><tr><th>Propriété</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>status</td><td>Number</td><td>Statut HTTP de la réponse (200 pour succès, 401/403 pour erreurs d&#39;auth, etc.)</td></tr><tr><td>error</td><td>String</td><td>Message d&#39;erreur (optionnel, utilisé pour les erreurs non-authentification)</td></tr></tbody></table><div class="div-code"><span class="color-neutral-700">// Exemple de retour pour une erreur d&#39;authentification</span><br> { status: 401, error: &quot;Unauthorized&quot; }<br><br><span class="color-neutral-700">// Exemple de retour pour une erreur serveur</span><br> { status: 500, error: &quot;Internal Server Error&quot; }<br><br><span class="color-neutral-700">// Exemple de retour pour un succès</span><br> { status: 200 } </div><h2 class="h2">Fonctions utilitaires</h2><h3 class="h3"><i class="fa-solid fa-link mr-5"></i>hydrate</h3><p> La fonction <span class="badge-code">hydrate</span> permet de charger automatiquement les entités complètes associées à des références d&#39;objets. Elle remplace les objets de référence simples (comme <span class="badge-code">{ id: 1 }</span>) par les entités complètes chargées depuis les controllers. </p><h4 class="h4">Paramètres</h4><table class="t-default mb-15 w-100"><thead><tr><th>Paramètre</th><th>Type</th><th>Obligatoire</th><th>Description</th></tr></thead><tbody><tr><td>data</td><td>Array</td><td>Oui</td><td>Tableau d&#39;objets contenant des références à hydrater</td></tr><tr><td>keys</td><td>Array&lt;string&gt;</td><td>Oui</td><td>Noms des clés à hydrater (ex: [&#39;patient&#39;, &#39;service&#39;])</td></tr><tr><td>config</td><td>Object</td><td>Non</td><td>Configuration optionnelle par clé (controller custom, filtre)</td></tr></tbody></table><h4 class="h4">Configuration par clé</h4><table class="t-default mb-15 w-100"><thead><tr><th>Option</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>controller</td><td>string</td><td>Nom du controller à utiliser (par défaut: nom de la clé)</td></tr><tr><td>filter</td><td>Function</td><td>Fonction de filtrage qui retourne <span class="badge-code">true</span> pour inclure l&#39;item ou <span class="badge-code">false</span> pour l&#39;exclure.</td></tr></tbody></table><h4 class="h4">Utilisation simple</h4><div class="div-code"> import { HydrateFunctions } from &#39;@brugmann/vuemann/src/services/utils/src/utils-hydrate.js&#39;<br><br><span class="color-neutral-700">// Données avec références simples</span><br> const hospitalizations = [<br>   { id: 1, patient: { id: 1 }, service: { id: 2 } },<br>   { id: 2, patient: { id: 2 }, service: { id: 2 } }<br> ]<br><br><span class="color-neutral-700">// Hydratation automatique</span><br> const hydratedData = await HydrateFunctions.hydrate(hospitalizations, [&#39;patient&#39;, &#39;service&#39;])<br><br><span class="color-neutral-700">// Résultat : les références sont remplacées par les entités complètes</span><br><span class="color-neutral-700">// hydratedData[0].patient = { id: 1, firstname: &#39;John&#39;, lastname: &#39;Doe&#39;, ... }</span></div><h4 class="h4">Avec filtre pour exclure des items</h4><div class="div-code"> const config = {<br>   patient: {<br>     <span class="color-neutral-700">// Ne charger que les patients des hospitalisations actives</span><br>     filter: (h) =&gt; h.status === &#39;active&#39;  <span class="color-neutral-700">// Retourne true ou false</span><br>   }<br> }<br><br> const hydratedData = await HydrateFunctions.hydrate(hospitalizations, [&#39;patient&#39;], config) </div><h4 class="h4">Exemples de filtres</h4><div class="div-code"><span class="color-success-500">// ✅ CORRECT : Retourne un boolean</span><br> filter: (h) =&gt; h.status === &#39;active&#39;<br> filter: (h) =&gt; h.id &gt; 10<br> filter: (h) =&gt; h.date !== null<br><br><span class="color-danger-500">// ❌ INCORRECT : Retourne un objet (transformation)</span><br> filter: (h) =&gt; ({ ...h, transformed: true })<br><br><span class="color-danger-500">// ❌ INCORRECT : Retourne l&#39;item ou false</span><br> filter: (h) =&gt; h.status === &#39;active&#39; ? h : false </div><h4 class="h4">Avec controller personnalisé</h4><div class="div-code"> const config = {<br>   practitioner: {<br>     <span class="color-neutral-700">// Utiliser le controller &quot;opera&quot; au lieu de &quot;practitioner&quot;</span><br>     controller: &#39;opera&#39;<br>   }<br> }<br><br> const hydratedData = await HydrateFunctions.hydrate(surgeries, [&#39;practitioner&#39;], config) </div><h4 class="h4">Prérequis</h4><p> Pour fonctionner correctement, la fonction <span class="badge-code">hydrate</span> nécessite que : </p><ul class="list ml-25 f-column g-5"><li>Les <strong>controllers</strong> concernés possèdent une méthode <span class="badge-code">byIds(ids)</span> qui accepte un tableau d&#39;IDs et retourne les entités correspondantes</li><li>Les objets de référence contiennent au minimum une propriété <span class="badge-code">id</span></li><li>Les controllers suivent la convention de nommage <span class="badge-code">{name}Controller</span> et sont situés dans <span class="badge-code">/src/apis/{name}/controllers/{name}-controller.js</span></li></ul><h4 class="h4">Exemple de méthode byIds dans un controller</h4><div class="div-code"><span class="color-neutral-700">// src/apis/patient/controllers/patient-controller.js</span><br> const byIds = async (ids) =&gt; {<br>   const response = await PatientRepository.byIds(ids)<br>   if (response.status !== STATUS.SUCCESS) {<br>     return { status: response.status, error: response.error }<br>   }<br><br>   return {<br>     status: STATUS.SUCCESS,<br>     data: response.data.map((patient) =&gt; PatientDto.fromShow(patient))<br>   }<br> }<br><br> export const PatientController = { byIds } </div><h4 class="h4">Avantages</h4><ul class="list ml-25 f-column g-5"><li><strong>Performance</strong> : Dédoublonne automatiquement les IDs et charge en batch</li><li><strong>Simplicité</strong> : Une seule fonction pour gérer plusieurs relations</li><li><strong>Flexibilité</strong> : Filtres et controllers personnalisés</li><li><strong>Immutabilité</strong> : Ne modifie pas les données originales</li></ul>',45))],64)}const g=r(p,[["render",h]]);export{g as default};
